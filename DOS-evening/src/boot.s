.code32

/*
    Этот код объявляет секцию .multiboot_header, содержащую информацию о заголовке протокола Multiboot 1. 
    Он предоставляет загрузчику информацию о типе заголовка, адресе точки входа, и других параметрах. 

    На метке _start, находится точка входа нашей операционной системы. 
    Однако, поскольку мы определяем этот адрес с помощью символа, определенного в нашем коде, _start может отличаться в зависимости от нашего C-кода.

    Другая важная часть - это контрольная сумма. Обычно она проверяется загрузчиком на корректность при загрузке. 
    Если контрольная сумма неверна, загрузчик будет считать измененным заголовок, и загрузка с диска не будет успешной.
*/
.section .multiboot
.align 4                    # Выравниваем секцию по 4-байтной границе
multiboot:
    .long 0x1BADB002          # заголовок boot magic
    .long 0x00                # флаги
    .long -(0x1BADB002 + 0x00)# контрольная сумма (магическое число + флаги) * -1

    .long _start              # адрес точки входа
    .long 0x00000000          # резервный адрес для стека

    .long 0x00                # количество областей памяти
    .long 0x00                # указатель области памяти

    .long 0x00                # длина имени загрузчика
    .long 0x00                # указатель на имя загрузчика
    .long 0x00                # указатель на командную строку
    .long 0x00                # модули

    .long 0x00                # флаг графического режима
    .long 0x00                # высота экрана
    .long 0x00                # ширина экрана
    .long 0x00                # bpp экрана


/*
    Метка "stack_bottom" указывает на начало стека, который выделяется в секции ".bss". 
    Используя директиву ".skip", выделяется 4 килобайта памяти для стека. 
    Метка "stack_top" указывает на вершину стека, которая находится в конце выделенной памяти. 
    Указатель стека устанавливается на вершину стека с помощью инструкции "mov" в секции text. 

    Это важно, так как стек используется для передачи параметров функций, адреса возврата и хранения локальных переменных. 
*/
.section .bss
.align 16                   # Выравниваем секцию по 16-байтной границе

# Объявляем точку начала стека и выделяем на него 4 килобайта
stack_bottom:
    .skip 1024 * 4          # 4 килобайт на стек
stack_top:



/*
    Вызываем код на C
*/
.section .text
.extern kernel_main
.global _start

# Начинаем исполнять код с метки _start
_start:
    cli                     # Отключаем прерывания
    mov $stack_top, %esp    # Начинаем стек в stack_top
    call kernel_main        # Вызываем функцию kernel_main
    cli                     # Отключаем прерывания в случае ошибки в kernel_main
_halt:
    hlt                     # Останавливаем процессор
    jmp _halt               # Возвращаемся на метку _halt на случай прерывания
